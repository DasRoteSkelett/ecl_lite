/**
 * @file /include/ecl/config/integral_types.hpp
 *
 * @brief Integer type definitions for various platforms.
 *
 * Integers have different bit sizes across platforms. Extend the definitions
 * for the platforms we use here. A good references is the *nix stdint.h
 * but this doesn't apply to MS Visual Studio. Another good cross-platform
 * reference is boost's version of this file.
 *
 * @date April 2009
 **/
/*****************************************************************************
** Defines
*****************************************************************************/

#ifndef ECL_CONFIG_INTEGRAL_TYPES_HPP_
#define ECL_CONFIG_INTEGRAL_TYPES_HPP_

/*****************************************************************************
** Includes
*****************************************************************************/

#include "portable_integers.hpp"
#include <limits.h>

/*****************************************************************************
** Namespaces
*****************************************************************************/

namespace ecl {

/*****************************************************************************
** Interface [Integer]
*****************************************************************************/
/**
 * @brief Compile time types and properties of 8/16/32/64 bit integers [primary template].
 *
 * Returns the integral type (signed and unsigned) used for the template argument
 * specified bit vector width (currently, only 8, 16, 32 or 64 are valid arguments).
 * Also returns various properties associated with the type (min, max, umax and
 * the a compile time equivalent for the various number macros).
 *
 * This is a virtual primary template class only and cannot be instantiated, use
 * the specialisations instead.
 *
 * <b>Example usage:</b>
 * @code
 * Integer<32>::type int_32;
 * Integer<32>::utype uint_32;
 *
 * int32 = Integer<32>::min
 * int32 = Integer<32>::max
 * int32 = Integer<32>::one
 * int32 = Integer<32>::uone
 * uint32 = Integer<32>::umax
 * @endcode
 *
 * @sa Integer<8>, Integer<16>, Integer<32>, Integer<64>
 **/
template <int N = 32> class Integer {
    private:
        Integer() {}; /**< Private constructor - cannot be instantiated. **/
};

/*****************************************************************************
** Interface [SizeOf]
*****************************************************************************/
/**
 * @brief Compile time equivalent of sizeof() for integral types [primary template].
 *
 * One would normally use sizeof() to determine this, but sizeof() is a runtime
 * function that can't be used as a template argument (for example, in the
 * Integer<N> class also defined here). So we use this one for compile time
 * size determination.
 *
 * This is a virtual primary template class only and cannot be instantiated, use
 * the specialisations instead.
 *
 * <b>Example usage:</b>
 *
 * @code
 * long size_of_long = SizeOf<long>::bytes; // on a 64bit machine, this will give 8.
 * long bits_of_long = SizeOf<long>::bits;  // on a 64bit machine, this will give 64.
 * long min_of_long  = SizeOf<long>::min;
 * long max_of_long  = SizeOf<long>::max;
 * @endcode
 *
 * @sa SizeOf<char>, SizeOf<unsigned char>, SizeOf<short>, SizeOf<unsigned short>, SizeOf<int>, SizeOf<unsigned int>, SizeOf<long>, SizeOf<unsigned long>, SizeOf<long long>, SizeOf<unsigned long long>
 *
 */
template <typename Type> class SizeOf {
    private:
        SizeOf() {}; /**< Private constructor - cannot be instantiated. **/
};

/*****************************************************************************
** 8 bit types
*****************************************************************************/

/**
 * @brief Compile time types and properties of 8 bit integers.
 *
 * Returns the integral types associated with 8 bit integers along with various
 * properties associated with those types.
 *
 * <b>Example usage:</b>
 *
 * Refer to this class's primary template, Integer, for example usage.
 *
 * @sa Integer
 **/
template <>
class Integer<8>
{
    public:
        typedef int8 type;                 /**< @brief Metafunction handle to the 8 bit integer type. **/
        typedef uint8 utype;               /**< @brief Metafunction handle to the 8 bit unsigned integer type. **/

        static const int8 min = CHAR_MIN;    /**< @brief Minimum arithmetic value. **/ //-127
        static const int8 max = CHAR_MAX;     /**< @brief Maximum arithmetic value. **/ //127
        static const int8 one = 1;         /**< @brief Signed value for one. **/
        static const uint8 uone = 1U;       /**< @brief Unsigned value for one. **/
        static const uint8 umin = 0U;      /**< @brief Maximum unsigned arithmetic value. **/
        static const uint8 umax = UCHAR_MAX;  /**< @brief Maximum unsigned arithmetic value. **/ //255U
};


/**
 * @brief Compile time equivalent of sizeof() for char types.
 *
 * Holds type properties for char types that can be used at compile time
 * (template argument passing).
 *
 * <b>Example usage:</b>
 *
 * Refer to this class's primary template, SizeOf, for example usage.
 *
 * @sa SizeOf
 */
template <> class SizeOf<char> {
    public:
        static const unsigned int bytes = 1; /**< @brief Number of bytes. **/
        static const int bits = 8;  /**< @brief Number of bits. **/
        static const int min =  CHAR_MIN;   /**< @brief Minimum arithmetic value. **/
        static const int max = CHAR_MAX;/**< @brief Maximum arithmetic value. **/
};

/**
 * @brief Compile time equivalent of sizeof() for unsigned char types.
 *
 * Holds type properties for unsigned char types that can be used at compile time
 * (template argument passing).
 *
 * <b>Example usage:</b>
 *
 * Refer to this class's primary template, SizeOf, for example usage.
 *
 * @sa SizeOf
 */
template <> class SizeOf<unsigned char> {
    public:
        static const unsigned int bytes = 1; /**< @brief Number of bytes. **/
        static const int bits = 8;  /**< @brief Number of bits. **/
        static const unsigned char min = 0; /**< @brief Minimum arithmetic value. **/
        static const unsigned char max = UCHAR_MAX;  /**< @brief Maximum arithmetic value. **/
};


/*****************************************************************************
** 16 bit types
*****************************************************************************/
#if ECL_SIZE_OF_SHORT == 2
    /**
     * @brief Compile time types and properties of 16 bit integers.
     *
     * Returns the integral types associated with 16 bit integers along with various
     * properties associated with those types.
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, Integer, for example usage.
     *
     * @sa Integer
     **/
    template <> class Integer<16>
    {
        public:
            typedef int16 type;                 /**< @brief Metafunction handle to the 16 bit integer type. **/
            typedef uint16 utype;               /**< @brief Metafunction handle to the 16 bit unsigned integer type. **/
            static const int16 min = SHRT_MIN;    /**< @brief Minimum arithmetic value. **/ //-32767
            static const int16 max = SHRT_MAX;     /**< @brief Maximum arithmetic value. **/ //32767
            static const int16 one = 1;         /**< @brief Signed value for one. **/
            static const uint16 uone = 1U;       /**< @brief Unsigned value for one. **/
            static const uint16 umin = 0U;      /**< @brief Maximum unsigned arithmetic value. **/
            static const uint16 umax = USHRT_MAX;  /**< @brief Maximum unsigned arithmetic value. **/ //65535U
    };

    /**
     * @brief Compile time equivalent of sizeof() for short types.
     *
     * Holds type properties for short types that can be used at compile time
     * (template argument passing).
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, SizeOf, for example usage.
     *
     * @sa SizeOf
     */
    template <> class SizeOf<short> {
        public:
            static const unsigned int bytes = 2;         /**< @brief Number of bytes. **/
            static const int bits = 16;         /**< @brief Number of bits. **/
            static const short min =  SHRT_MIN;   /**< @brief Minimum arithmetic value. **/
            static const short max = SHRT_MAX;     /**< @brief Maximum arithmetic value. **/
    };

    /**
     * @brief Compile time equivalent of sizeof() for unsigned short types.
     *
     * Holds type properties for unsigned short types that can be used at compile time
     * (template argument passing).
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, SizeOf, for example usage.
     *
     * @sa SizeOf
     */
    template <> class SizeOf<unsigned short> {
        public:
            static const unsigned int bytes = 2;         /**< @brief Number of bytes. **/
            static const int bits = 16;         /**< @brief Number of bits. **/
            static const unsigned short min =  0;        /**< @brief Minimum arithmetic value. **/
            static const unsigned short max = USHRT_MAX ; /**< @brief Maximum arithmetic value. **/ // 65535U
    };

#endif

/*****************************************************************************
** 32 bit types
*****************************************************************************/

#if ECL_SIZE_OF_INT == 4 // 32 bit & 64 bit processors
    /**
     * @brief Compile time types and properties of 32 bit integers.
     *
     * Returns the integral types associated with 32 bit integers along with various
     * properties associated with those types.
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, Integer, for example usage.
     *
     * @sa Integer
     **/
    template <> class Integer<32>
    {
        public:
            typedef int32 type;                     /**< @brief Metafunction handle to the 32 bit integer type. **/
            typedef uint32 utype;                   /**< @brief Metafunction handle to the 32 bit unsigned integer type. **/
            static const int32 min = INT_MIN;   /**< @brief Minimum arithmetic value. **/ //-2147483647
            static const int32 max = INT_MAX;    /**< @brief Maximum arithmetic value. **/ //2147483647
            static const int32 one = 1;             /**< @brief Signed value for one. **/
            static const uint32 uone = 1U;           /**< @brief Unsigned value for one. **/
            static const uint32 umin = 0U;          /**< @brief Maximum unsigned arithmetic value. **/
            static const uint32 umax = UINT_MAX; /**< @brief Maximum unsigned arithmetic value. **/ //4294967295U
    };

    /**
     * @brief Compile time equivalent of sizeof() for int types.
     *
     * Holds type properties for int types that can be used at compile time
     * (template argument passing).
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, SizeOf, for example usage.
     *
     * @sa SizeOf
     */
    template <> class SizeOf<int> {
        public:
            static const unsigned int bytes = 4;         /**< @brief Number of bytes. **/
            static const int bits = 32;         /**< @brief Number of bits. **/
            static const int min = INT_MIN; /**< @brief Minimum arithmetic value. **/ //-2147483647
            static const int max = INT_MAX;  /**< @brief Maximum arithmetic value. **/ // -2147483647
    };

    /**
     * @brief Compile time equivalent of sizeof() for unsigned int types.
     *
     * Holds type properties for unsigned int types that can be used at compile time
     * (template argument passing).
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, SizeOf, for example usage.
     *
     * @sa SizeOf
     */
    template <> class SizeOf<unsigned int> {
        public:
            static const unsigned int bytes = 4;             /**< @brief Number of bytes. **/
            static const int bits = 32;             /**< @brief Number of bits. **/
            static const unsigned int min =  0;     /**< @brief Minimum arithmetic value. **/
            static const unsigned int max = UINT_MAX; /**< @brief Maximum arithmetic value. **/ //4294967295U
    };
#endif

/*****************************************************************************
** 64 bit types
*****************************************************************************/

#if ECL_SIZE_OF_LONG == 8
    /**
     * @brief Compile time types and properties of 64 bit integers.
     *
     * Returns the integral types associated with 64 bit integers along with various
     * properties associated with those types.
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, Integer, for example usage.
     *
     * @sa Integer
     **/
    template <> struct Integer<64>
    {
        typedef int64 type;                                 /**< @brief Metafunction handle to the 64 bit integer type. **/
        typedef uint64 utype;                               /**< @brief Metafunction handle to the 64 bit unsigned integer type. **/
        static const int64 min = LONG_MIN;     /**< @brief Minimum arithmetic value. **/ //-9223372036854775807L
        static const int64 one = 1L;                        /**< @brief Signed value for one. **/
        static const int64 max = LONG_MAX;      /**< @brief Maximum arithmetic value. **/ //9223372036854775807L
        static const uint64 uone = 1UL;                      /**< @brief Unsigned value for one. **/
        static const uint64 umin = 0UL;                     /**< @brief Maximum unsigned arithmetic value. **/
        static const uint64 umax = ULONG_MAX; /**< @brief Maximum unsigned arithmetic value. **/ //18446744073709551615UL
    };
    /**
     * @brief Compile time equivalent of sizeof() for long types.
     *
     * Holds type properties for int types that can be used at compile time
     * (template argument passing).
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, SizeOf, for example usage.
     *
     * @sa SizeOf
     */
    template <> class SizeOf<long> {
        public:
            static const unsigned int bytes = 8;         /**< @brief Number of bytes. **/
            static const int bits = 64;         /**< @brief Number of bits. **/
            static const long min =  LONG_MIN; /**< @brief Minimum arithmetic value. **/ //-9223372036854775807L
            static const long max = LONG_MAX;   /**< @brief Maximum arithmetic value. **/ //9223372036854775807L
    };

    /**
     * @brief Compile time equivalent of sizeof() for long types.
     *
     * Holds type properties for int types that can be used at compile time
     * (template argument passing).
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, SizeOf, for example usage.
     *
     * @sa SizeOf
     */
    template <> class SizeOf<unsigned long> {
        public:
            static const unsigned int bytes = 8;         /**< @brief Number of bytes. **/
            static const int bits = 64;         /**< @brief Number of bits. **/
            static const unsigned long min =  0UL;                      /**< @brief Minimum arithmetic value. **/
            static const unsigned long max = ULONG_MAX;    /**< @brief Maximum arithmetic value. **/ //18446744073709551615UL
    };

#elif ECL_SIZE_OF_LONG_LONG == 8

    /**
     * @brief Compile time types and properties of 64 bit integers.
     *
     * Returns the integral types associated with 64 bit integers along with various
     * properties associated with those types.
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, Integer, for example usage.
     *
     * @sa Integer
     **/
    template <> struct Integer<64>
    {
        typedef int64 type;                                 /**< @brief Metafunction handle to the 64 bit integer type. **/
        typedef uint64 utype;                               /**< @brief Metafunction handle to the 64 bit unsigned integer type. **/
        static const int64 min = LONG_LONG_MIN;     /**< @brief Minimum arithmetic value. **/ //-9223372036854775807LL
        static const int64 one = 1LL;                        /**< @brief Signed value for one. **/
        static const int64 max = LONG_LONG_MAX;      /**< @brief Maximum arithmetic value. **/ //9223372036854775807LL
        static const uint64 uone = 1ULL;                       /**< @brief Unsigned value for one. **/
        static const uint64 umin = 0ULL;                      /**< @brief Maximum unsigned arithmetic value. **/
        static const uint64 umax = ULONG_LONG_MAX; /**< @brief Maximum unsigned arithmetic value. **/ //18446744073709551615ULL
    };

    // In this case, long is 4 bytes ( see initial part of #if definition)
    /**
     * @brief Compile time equivalent of sizeof() for long types.
     *
     * Holds type properties for int types that can be used at compile time
     * (template argument passing).
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, SizeOf, for example usage.
     *
     * @sa SizeOf
     */
    template <> class SizeOf<long> {
        public:
            static const unsigned int bytes = 4;         /**< @brief Number of bytes. **/
            static const int bits = 32;         /**< @brief Number of bits. **/
            static const long min =  LONG_MIN; /**< @brief Minimum arithmetic value. **/ //-2147483647L
            static const long max = LONG_MAX;   /**< @brief Maximum arithmetic value. **/ //2147483647L
    };

    /**
     * @brief Compile time equivalent of sizeof() for long types.
     *
     * Holds type properties for int types that can be used at compile time
     * (template argument passing).
     *
     * <b>Example usage:</b>
     *
     * Refer to this class's primary template, SizeOf, for example usage.
     *
     * @sa SizeOf
     */
    template <> class SizeOf<unsigned long> {
        public:
            static const unsigned int bytes = 4;         /**< @brief Number of bytes. **/
            static const int bits = 32;         /**< @brief Number of bits. **/
            static const unsigned long min =  0UL;                      /**< @brief Minimum arithmetic value. **/
            static const unsigned long max = ULONG_MAX;    /**< @brief Maximum arithmetic value. **/ //4294967295UL
    };
#endif

/**
 * @brief Compile time equivalent of sizeof() for long long types.
 *
 * Holds type properties for int types that can be used at compile time
 * (template argument passing).
 *
 * <b>Example usage:</b>
 *
 * Refer to this class's primary template, SizeOf, for example usage.
 *
 * @sa SizeOf
 */
template <> class SizeOf<long long> {
    public:
        static const unsigned int bytes = 8;                             /**< @brief Number of bytes. **/
        static const int bits = 64;                             /**< @brief Number of bits. **/
        static const long long min =  LONG_LONG_MIN;   /**< @brief Minimum arithmetic value. **/ //-9223372036854775807LL
        static const long long max = LONG_LONG_MAX;     /**< @brief Maximum arithmetic value. **/ //9223372036854775807LL
};

/**
 * @brief Compile time equivalent of sizeof() for unsigned long long types.
 *
 * Holds type properties for int types that can be used at compile time
 * (template argument passing).
 *
 * <b>Example usage:</b>
 *
 * Refer to this class's primary template, SizeOf, for example usage.
 *
 * @sa SizeOf
 */
template <> class SizeOf<unsigned long long> {
    public:
        static const unsigned int bytes = 8;                                      /**< @brief Number of bytes. **/
        static const int bits = 64;                                     /**< @brief Number of bits. **/
        static const unsigned long long min =  0;                       /**< @brief Minimum arithmetic value. **/
        static const unsigned long long max = ULONG_LONG_MAX;  /**< @brief Maximum arithmetic value. **/ // 18446744073709551615ULL
};

/*****************************************************************************
** Signed to Unsigned Template MetaConversions
*****************************************************************************/
/** @brief Primary template for signed to unsigned type metafunctions. **/
template <typename Signed> struct Unsigned {};

/** @brief Metafunction for char to unsigned char type conversions. **/
template <> struct Unsigned<char> { typedef unsigned char type; /**< The unsigned equivalent. **/ };
/** @brief Metafunction for short to unsigned short type conversions. **/
template <> struct Unsigned<short> { typedef unsigned short type; /**< The unsigned equivalent. **/};
/** @brief Metafunction for int to unsigned int type conversions. **/
template <> struct Unsigned<int> { typedef unsigned int type; /**< The unsigned equivalent. **/};
/** @brief Metafunction for long to unsigned long type conversions. **/
template <> struct Unsigned<long> { typedef unsigned long type; /**< The unsigned equivalent. **/};
/** @brief Metafunction for long long to unsigned long long type conversions. **/
template <> struct Unsigned<long long> { typedef unsigned long long type; /**< The unsigned equivalent. **/};

/** @brief Metafunction returning same type for unsigned chars. **/
template <> struct Unsigned<unsigned char> { typedef unsigned char type; /**< The unsigned equivalent. **/ };
/** @brief Metafunction returning same type for unsigned shorts. **/
template <> struct Unsigned<unsigned short> { typedef unsigned short type; /**< The unsigned equivalent. **/};
/** @brief Metafunction returning same type for unsigned ints. **/
template <> struct Unsigned<unsigned int> { typedef unsigned int type; /**< The unsigned equivalent. **/};
/** @brief Metafunction returning same type for unsigned longs. **/
template <> struct Unsigned<unsigned long> { typedef unsigned long type; /**< The unsigned equivalent. **/};
/** @brief Metafunction returning same type for unsigned long longs. **/
template <> struct Unsigned<unsigned long long> { typedef unsigned long long type; /**< The unsigned equivalent. **/};

} // Namespace ecl


#endif /*ECL_CONFIG_INTEGRAL_TYPES_HPP_*/
