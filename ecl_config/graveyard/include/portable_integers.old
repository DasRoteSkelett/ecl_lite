/**
 * @file /ecl_config/include/ecl/config/portable_integers.hpp
 *
 * @brief Portable implementation of some of what's in stdint.h
 *
 * As far as I know, all gnu and msvc implementations support
 * climits. I may be massively naive here though!
 *
 * cstdint is a different matter though, its part of c++0x.
 * Note, we can't check for __STDC_VERSION__ which would be the usual way
 * of checking for a complete c version as it is not defined when compiling
 * for c++.
 *
 * Also, the cpp way of checking via __cplusplus doesn't work as g++ defines
 * this to 1 only since its not a fully compliant version yet (should normally
 * expand to a date string).
 *
 * Some other documents maybe worth checking include:
 *
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 *   http://msinttypes.googlecode.com/svn/trunk/stdint.h
 *   http://www.boost.org/doc/libs/1_37_0/boost/cstdint.hpp
 *
 * @date February 2011
 **/
/*****************************************************************************
** Ifdefs
*****************************************************************************/

#ifndef ECL_PORTABLE_INTEGERS_HPP_
#define ECL_PORTABLE_INTEGERS_HPP_

/*****************************************************************************
** Includes
*****************************************************************************/

#include "ecl.hpp"
#include <limits>

/*
 * Could use an extra check for cstdint
 */
#ifdef ECL_HAS_STDINT_H
	#include <stdint.h>
	#define ECL_STDINT_H_INCLUDED
#elif defined(__GNUC__)
	#if __GXX_EXPERIMENTAL_CXX0X__ > 0
		#include <cstdint>
		#define ECL_CSTDINT_INCLUDED
		#define ECL_STDINT_H_INCLUDED
	#else
		#include <stdint.h>
		#define ECL_STDINT_H_INCLUDED
	#endif
#elif (defined(__STDC__) && __STDC__)
	#include <stdint.h>
	#define ECL_STDINT_H_INCLUDED
#else
	// possibly other combinations
#endif

/*****************************************************************************
** Custom Implementation
*****************************************************************************/

//#ifndef ECL_STDINT_H_INCLUDED
//	#ifndef SIZE_MAX
//		# define SIZE_MAX (~(size_t)0)
//	#endif
//
//	/*
//	 *  Deduce the type assignments from limits.h under the assumption that
//	 *  integer sizes in bits are powers of 2, and follow the ANSI
//	 *  definitions.
//	 */
//	#ifndef UINT8_MAX
//		#define UINT8_MAX 0xff
//	#endif
//	#ifndef uint8_t
//		#if (UCHAR_MAX == UINT8_MAX) || defined (S_SPLINT_S)
//			typedef unsigned char uint8_t;
//			#define UINT8_C(v) ((uint8_t) v)
//		#else
//			#error "Platform not supported"
//		#endif
//	#endif
//
//	#ifndef INT8_MAX
//		#define INT8_MAX 0x7f
//	#endif
//	#ifndef INT8_MIN
//		#define INT8_MIN INT8_C(0x80)
//	#endif
//	#ifndef int8_t
//		#if (SCHAR_MAX == INT8_MAX) || defined (S_SPLINT_S)
//			typedef signed char int8_t;
//			#define INT8_C(v) ((int8_t) v)
//		#else
//			#error "Platform not supported"
//		#endif
//	#endif
//
//	#ifndef UINT16_MAX
//		#define UINT16_MAX 0xffff
//	#endif
//	#ifndef uint16_t
//		#if (UINT_MAX == UINT16_MAX) || defined (S_SPLINT_S)
//			typedef unsigned int uint16_t;
//			#ifndef PRINTF_INT16_MODIFIER
//				#define PRINTF_INT16_MODIFIER ""
//			#endif
//			#define UINT16_C(v) ((uint16_t) (v))
//		#elif (USHRT_MAX == UINT16_MAX)
//			typedef unsigned short uint16_t;
//			#define UINT16_C(v) ((uint16_t) (v))
//		#else
//			#error "Platform not supported"
//		#endif
//	#endif
//
//	#ifndef INT16_MAX
//		#define INT16_MAX 0x7fff
//	#endif
//	#ifndef INT16_MIN
//		#define INT16_MIN INT16_C(0x8000)
//	#endif
//	#ifndef int16_t
//		#if (INT_MAX == INT16_MAX) || defined (S_SPLINT_S)
//			typedef signed int int16_t;
//			#define INT16_C(v) ((int16_t) (v))
//			#ifndef PRINTF_INT16_MODIFIER
//				#define PRINTF_INT16_MODIFIER ""
//			#endif
//		#elif (SHRT_MAX == INT16_MAX)
//			typedef signed short int16_t;
//			#define INT16_C(v) ((int16_t) (v))
//		#else
//			#error "Platform not supported"
//		#endif
//	#endif
//
//	#ifndef UINT32_MAX
//		#define UINT32_MAX (0xffffffffUL)
//	#endif
//	#ifndef uint32_t
//		#if (ULONG_MAX == UINT32_MAX) || defined (S_SPLINT_S)
//			typedef unsigned long uint32_t;
//			#define UINT32_C(v) v ## UL
//			#ifndef PRINTF_INT32_MODIFIER
//				#define PRINTF_INT32_MODIFIER "l"
//			#endif
//		#elif (UINT_MAX == UINT32_MAX)
//			typedef unsigned int uint32_t;
//			#ifndef PRINTF_INT32_MODIFIER
//				#define PRINTF_INT32_MODIFIER ""
//			#endif
//			#define UINT32_C(v) v ## U
//		#elif (USHRT_MAX == UINT32_MAX)
//			typedef unsigned short uint32_t;
//			#define UINT32_C(v) ((unsigned short) (v))
//			#ifndef PRINTF_INT32_MODIFIER
//				#define PRINTF_INT32_MODIFIER ""
//			#endif
//		#else
//			#error "Platform not supported"
//		#endif
//	#endif
//
//	#ifndef INT32_MAX
//		#define INT32_MAX (0x7fffffffL)
//	#endif
//	#ifndef INT32_MIN
//		#define INT32_MIN INT32_C(0x80000000)
//	#endif
//	#ifndef int32_t
//		#if (LONG_MAX == INT32_MAX) || defined (S_SPLINT_S)
//			typedef signed long int32_t;
//			#define INT32_C(v) v ## L
//		#elif (INT_MAX == INT32_MAX)
//			typedef signed int int32_t;
//			#define INT32_C(v) v
//		#elif (SHRT_MAX == INT32_MAX)
//			typedef signed short int32_t;
//			#define INT32_C(v) ((short) (v))
//		#else
//			#error "Platform not supported"
//		#endif
//	#endif
//
//	/*
//	 *  The macro stdint_int64_defined is temporarily used to record
//	 *  whether or not 64 integer support is available.  It must be
//	 *  defined for any 64 integer extensions for new platforms that are
//	 *  added.
//	 */
//	#undef stdint_int64_defined
//	#if (defined(__STDC__) && defined(__STDC_VERSION__)) || defined (S_SPLINT_S)
//		#if (__STDC__ && __STDC_VERSION >= 199901L) || defined (S_SPLINT_S)
//			#define stdint_int64_defined
//			typedef long long int64_t;
//			typedef unsigned long long uint64_t;
//			#define UINT64_C(v) v ## ULL
//			#define  INT64_C(v) v ## LL
//		#endif
//	#endif
//
//	#if !defined (stdint_int64_defined)
//		#if defined(__GNUC__)
//			#define stdint_int64_defined
//				__extension__ typedef long long int64_t;
//				__extension__ typedef unsigned long long uint64_t;
//			#define UINT64_C(v) v ## ULL
//			#define  INT64_C(v) v ## LL
//		#elif defined (__APPLE_CC__) || defined (_LONG_LONG) || defined (S_SPLINT_S)
//			#define stdint_int64_defined
//			typedef long long int64_t;
//			typedef unsigned long long uint64_t;
//			#define UINT64_C(v) v ## ULL
//			#define  INT64_C(v) v ## LL
//		#elif (defined(_MSC_VER) && _INTEGRAL_MAX_BITS >= 64)
//			#define stdint_int64_defined
//			typedef __int64 int64_t;
//			typedef unsigned __int64 uint64_t;
//			#define UINT64_C(v) v ## UI64
//			#define  INT64_C(v) v ## I64
//		#endif
//	#endif
//
//	#if !defined (LONG_LONG_MAX) && defined (INT64_C)
//		#define LONG_LONG_MAX INT64_C (9223372036854775807)
//	#endif
//	#ifndef ULONG_LONG_MAX
//		#define ULONG_LONG_MAX UINT64_C (18446744073709551615)
//	#endif
//
//	#if !defined (INT64_MAX) && defined (INT64_C)
//		#define INT64_MAX INT64_C (9223372036854775807)
//	#endif
//	#if !defined (INT64_MIN) && defined (INT64_C)
//		#define INT64_MIN INT64_C (-9223372036854775808)
//	#endif
//	#if !defined (UINT64_MAX) && defined (INT64_C)
//		#define UINT64_MAX UINT64_C (18446744073709551615)
//	#endif
//
//	/*
//	 *  Ok, lets not worry about 128 bit integers for now.  Moore's law says
//	 *  we don't need to worry about that until about 2040 at which point
//	 *  we'll have bigger things to worry about.
//	 */
//	#ifdef stdint_int64_defined
//		typedef int64_t intmax_t;
//		typedef uint64_t uintmax_t;
//		#define  INTMAX_MAX   INT64_MAX
//		#define  INTMAX_MIN   INT64_MIN
//		#define UINTMAX_MAX  UINT64_MAX
//		#define UINTMAX_C(v) UINT64_C(v)
//		#define  INTMAX_C(v)  INT64_C(v)
//	#else
//		typedef int32_t intmax_t;
//		typedef uint32_t uintmax_t;
//		#define  INTMAX_MAX   INT32_MAX
//		#define UINTMAX_MAX  UINT32_MAX
//		#define UINTMAX_C(v) UINT32_C(v)
//		#define  INTMAX_C(v)  INT32_C(v)
//	#endif
//	#undef stdint_int64_defined
//
//#endif // Custom implementation of integers (#ifndef ECL_STDINT_H_INCLUDED

/*****************************************************************************
** Typedefs
*****************************************************************************/

namespace ecl {

typedef int8_t int8;		/**< @brief An alias for the platform's 8 bit integer type. **/
typedef uint8_t uint8;		/**< @brief An alias for the platform's unsigned 8 bit integer type. **/
typedef int16_t int16;		/**< @brief An alias for the platform's 16 bit integer type. **/
typedef uint16_t uint16;	/**< @brief An alias for the platform's unsigned 16 bit integer type. **/
typedef int32_t int32;		/**< @brief An alias for the platform's 32 bit integer type. **/
typedef uint32_t uint32; 	/**< @brief An alias for the platform's unsigned 32 bit integer type. **/
typedef int64_t int64; 		/**< @brief An alias for the platform's 64 bit integer type. **/
typedef uint64_t uint64; 	/**< @brief An alias for the platform's unsigned 64 bit integer type. **/

}; // namespace ecl

/*****************************************************************************
** Macros
*****************************************************************************/

///*
// * This may be a bit naive, but seems to be always the case.
// */
//#ifndef INT8_MIN
//  #define INT8_MIN CHAR_MIN
//#endif
//#ifndef INT8_MAX
//	#define INT8_MAX CHAR_MAX
//#endif
//#ifndef UINT8_MIN
//	#define UINT8_MIN 0
//#endif
//#ifndef UINT8_MAX
//	#define UINT8_MAX UCHAR_MAX
//#endif


#endif /* ECL_PORTABLE_INTEGERS_HPP_ */
